Understanding Real-World Concurrency Bugs in Go

Go é uma linguagem de programação de tipagem estática que tem como objetivo fornecer uma maneira simples, eficiente e segura de construir software multithreaded. Desde a sua criação em 2009, o Go amadureceu e ganhou uma adoção significativa em software de produção e de código aberto. O Go advoga o uso de passagem de mensagens como meio de comunicação entre threads e fornece diversos novos mecanismos de concorrência e bibliotecas para facilitar a programação multithread. É importante compreender as implicações dessas novas propostas e a comparação entre passagem de mensagens e sincronização de memória compartilhada em termos de erros ou bugs de programa. Infelizmente, até onde sabemos, não houve nenhum estudo sobre os bugs de concorrência no Go.

Neste artigo, realizamos o primeiro estudo sistemático sobre bugs de concorrência em programas Go reais. Estudamos seis softwares populares em Go, incluindo Docker, Kubernetes e gRPC. Analisamos um total de 171 bugs de concorrência, sendo que mais da metade deles foi causada por problemas não tradicionais específicos do Go. Além das causas raiz desses bugs, também estudamos suas correções, realizamos experimentos para reproduzi-los e os avaliamos com dois detectores de bugs Go disponíveis publicamente.

No geral, nosso estudo fornece uma melhor compreensão dos modelos de concorrência do Go e pode orientar futuros pesquisadores e profissionais na escrita de software Go melhor e mais confiável, bem como no desenvolvimento de ferramentas de depuração e diagnóstico para o Go.

## Introducao

O Go [20] é uma linguagem de programação de tipagem estática originalmente desenvolvida pelo Google em 2009. Nos últimos anos, ele rapidamente ganhou popularidade e agora é adotado por muitos tipos de software em produção real. Essas aplicações em Go abrangem desde bibliotecas [19] e software de alto nível [26] até software de infraestrutura em nuvem, como sistemas de contêineres [13, 36] e bancos de dados chave-valor [10, 15].

Um objetivo importante do design do Go é melhorar as linguagens de programação tradicionais multithreaded e tornar a programação concorrente mais fácil e menos propensa a erros. Para isso, o Go centra seu design de multithreading em torno de dois princípios: 1) tornar as threads (chamadas goroutines) leves e fáceis de criar e 2) usar mensagens explícitas (chamadas canais) para comunicar entre as threads. Com esses princípios de design, o Go propõe não apenas um conjunto de novas primitivas e bibliotecas, mas também uma nova implementação de semânticas existentes.

É crucial entender como as novas primitivas e mecanismos de concorrência do Go afetam os bugs de concorrência, que são os tipos de bugs mais difíceis de depurar e mais amplamente estudados [40, 43, 45, 57, 61] em linguagens tradicionais de programação multithread. Infelizmente, não houve trabalhos anteriores no estudo de bugs de concorrência no Go. Como resultado, até o momento, ainda não está claro se esses mecanismos de concorrência tornam realmente o Go mais fácil de programar e menos propenso a bugs de concorrência do que as linguagens tradicionais.

Neste artigo, conduzimos o primeiro estudo empírico sobre bugs de concorrência no Go usando seis aplicativos Go de código aberto e de alta qualidade em produção: Docker [13] e Kubernetes [36], dois sistemas de contêineres para data centers, etcd [15], um sistema distribuído de armazenamento chave-valor, gRPC [19], uma biblioteca RPC, e CockroachDB [10] e BoltDB [6], dois sistemas de bancos de dados. No total, estudamos 171 bugs de concorrência nessas aplicações. Analisamos as causas raiz deles, realizamos experimentos para reproduzi-los e examinamos as correções. Por fim, testamos esses bugs com dois detectores de bugs de concorrência Go existentes (os únicos publicamente disponíveis).

Nosso estudo se concentra em uma questão antiga e fundamental na programação concorrente: entre passagem de mensagens [27, 37] e memória compartilhada, qual desses mecanismos de comunicação entre threads é menos propenso a erros [2, 11, 48]. O Go é a linguagem perfeita para estudar essa questão, pois fornece estruturas para tanto memória compartilhada quanto passagem de mensagens. No entanto, ele incentiva o uso de canais em vez de memória compartilhada com a crença de que a passagem explícita de mensagens é menos propensa a erros [1, 2, 21].

Para entender os bugs de concorrência no Go e a comparação entre passagem de mensagens e memória compartilhada, propomos categorizar os bugs de concorrência ao longo de duas dimensões ortogonais: a causa dos bugs e o seu comportamento. Na dimensão da causa, categorizamos os bugs em aqueles causados pelo uso inadequado de memória compartilhada e aqueles causados pelo uso inadequado de passagem de mensagens. Na segunda dimensão, separamos os bugs em aqueles que envolvem (qualquer número de) goroutines que não podem avançar (chamamos de bugs de bloqueio) e aqueles que não envolvem bloqueio algum (bugs não bloqueantes).

Surpreendentemente, nosso estudo mostra que é tão fácil criar bugs de concorrência com passagem de mensagens quanto com memória compartilhada, às vezes até mais. Por exemplo, cerca de 58% dos bugs de bloqueio são causados pela passagem de mensagens. Além da violação das regras de uso de canais do Go (por exemplo, esperar por um canal para o qual ninguém envia dados ou fechar um canal), muitos bugs de concorrência são causados ​​pelo uso misto de passagem de mensagens e outras novas semânticas e bibliotecas no Go, o que pode ser facilmente negligenciado, mas é difícil de detectar.

Para demonstrar erros na passagem de mensagens, usamos um bug de bloqueio do Kubernetes na Figura 1. A função finishReq cria uma goroutine filha usando uma função anônima na linha 4 para lidar com uma solicitação - uma prática comum em programas de servidor Go. A goroutine filha executa fn() e envia o resultado de volta para a goroutine pai por meio do canal ch na linha 6. A goroutine filha ficará bloqueada na linha 6 até que o pai retire o resultado de ch na linha 9. Enquanto isso, o pai ficará bloqueado no select até que ocorra um timeout (linha 11) ou quando a execução Go (de forma não determinística) escolhe o caso na linha 11 quando ambos os casos são válidos. Se o timeout ocorrer antes ou se a execução Go escolher o caso na linha 11, o pai retornará de requestReq() na linha 12, e ninguém mais poderá retirar o resultado de ch, resultando na goroutine filha ficando bloqueada indefinidamente. A correção é alterar ch de um canal não bufferizado para um canal bufferizado, para que a goroutine filha possa sempre enviar o resultado mesmo quando o pai já tiver saído.

Esse bug demonstra a complexidade de usar novos recursos no Go e a dificuldade em escrever programas Go corretos como este. Os programadores precisam ter um entendimento claro da criação de goroutines com função anônima, um recurso que o Go propõe para facilitar a criação de goroutines, o uso de canais com ou sem buffer, a não determinismo na espera por múltiplas operações de canal usando select e a biblioteca especial de tempo. Embora cada um desses recursos tenha sido projetado para facilitar a programação multithread, na prática, é difícil escrever programas Go corretos com eles.

No geral, nosso estudo revela novas práticas e novos problemas na programação concorrente em Go, e lança luz sobre uma resposta para o debate entre passagem de mensagens e acessos à memória compartilhada. Nossas descobertas melhoram a compreensão da concorrência em Go e podem fornecer orientações valiosas para o desenvolvimento futuro de ferramentas. Este artigo apresenta as seguintes contribuições-chave:

Realizamos o primeiro estudo empírico de bugs de concorrência em Go com seis aplicativos Go do mundo real e de alta qualidade em produção.
Fizemos nove observações-chave em alto nível sobre as causas, correções e detecção de bugs de concorrência em Go. Elas podem ser úteis como referência para programadores Go. Além disso, fornecemos oito insights sobre as implicações de nossos resultados para orientar futuras pesquisas no desenvolvimento, teste e detecção de bugs em Go.
Propusemos novos métodos para categorizar bugs de concorrência ao longo de duas dimensões: causas dos bugs e comportamento. Essa metodologia de taxonomia nos ajudou a comparar melhor diferentes mecanismos de concorrência e correlações entre causas e correções de bugs. Acreditamos que outros estudos de bugs podem utilizar métodos de taxonomia semelhantes.
Todos os resultados de nosso estudo e os registros de commits estudados podem ser encontrados em https://github.com/system-pclub/go-concurrency-bugs.

O Go defende tornar a criação de threads fácil e leve e o uso da passagem de mensagens em vez de memória compartilhada para a comunicação entre threads. De fato, vimos mais goroutines criadas em programas Go do que threads tradicionais e há um uso significativo de canais do Go e outros mecanismos de passagem de mensagens. No entanto, nosso estudo mostrou que, se não forem usados corretamente, essas duas práticas de programação podem potencialmente causar bugs de concorrência.

Memória compartilhada vs. passagem de mensagens. Nosso estudo constatou que a passagem de mensagens não necessariamente torna os programas multithread menos propensos a erros do que a memória compartilhada. Na verdade, a passagem de mensagens é a principal causa de bugs de bloqueio. Para piorar, quando combinada com primitivas de sincronização tradicionais ou com outros recursos e bibliotecas de linguagem novos, a passagem de mensagens pode causar bugs de bloqueio que são muito difíceis de detectar. A passagem de mensagens causa menos bugs não bloqueantes do que a sincronização de memória compartilhada e, surpreendentemente, foi usada até mesmo para corrigir bugs causados por sincronização de memória compartilhada incorreta. Acreditamos que a passagem de mensagens oferece uma forma limpa de comunicação entre threads e pode ser útil para a passagem de dados e sinais. Mas eles são úteis apenas se usados corretamente, o que requer que os programadores entendam não apenas os mecanismos de passagem de mensagens, mas também outros mecanismos de sincronização do Go.

Implicações na detecção de bugs. Nosso estudo revela muitos padrões de código com bugs que podem ser explorados para realizar a detecção de bugs de concorrência. Como um esforço preliminar, construímos um detector que visa os bugs não bloqueantes causados por funções anônimas (por exemplo, Figura 8). Nosso detector já descobriu alguns novos bugs, um dos quais foi confirmado por desenvolvedores de aplicativos reais [12]. De forma mais geral, acreditamos que a análise estática, juntamente com algoritmos de detecção de deadlock existentes, ainda será útil na detecção da maioria dos bugs de bloqueio do Go causados por erros na sincronização de memória compartilhada. Tecnologias estáticas também podem ajudar na detecção de bugs causados ​​pela combinação de canais e bloqueios, como o exemplo na Figura 7. O uso incorreto das bibliotecas do Go pode causar tanto bugs de bloqueio quanto bugs não bloqueantes. Resumimos vários padrões de uso inadequado das bibliotecas do Go em nosso estudo. Detectores podem aproveitar os padrões que aprendemos para revelar bugs previamente desconhecidos. Nosso estudo também encontrou a violação das regras que o Go impõe com suas primitivas de concorrência como uma das principais razões para bugs de concorrência. Uma técnica dinâmica inovadora pode tentar impor essas regras e detectar violações em tempo de execução.

Como uma linguagem de programação projetada para concorrência, o Go oferece goroutines leves e passagem de mensagens baseada em canais entre goroutines. Diante do aumento do uso do Go em diversos tipos de aplicativos, este artigo realiza o primeiro estudo abrangente e empírico de 171 bugs de concorrência reais do Go em duas dimensões ortogonais. Muitas descobertas interessantes e implicações são apresentadas em nosso estudo. Esperamos que nosso estudo aprofunde a compreensão dos bugs de concorrência no Go e chame mais atenção para esses bugs.
