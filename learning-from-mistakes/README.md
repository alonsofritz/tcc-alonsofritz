# Learning from Mistakes - A Comprehensive Study on Real World Concurrency Bug Characteristics

## Abstract

A realidade do hardware multi-core tornou os programas concorrentes predominantes. Infelizmente, escrever programas concorrentes corretos é uma tarefa difícil. Lidar com esse desafio requer avanços em várias direções, incluindo detecção de bugs de concorrência, testes de programas concorrentes, design de modelos de programação concorrente, etc. Projetar técnicas eficazes em todas essas direções se beneficiará significativamente de uma compreensão profunda das características reais de bugs de concorrência.

Este artigo fornece o primeiro estudo abrangente (até onde sabemos) das características reais de bugs de concorrência. Especificamente, examinamos cuidadosamente padrões de bugs de concorrência, manifestações e estratégias de correção de 105 bugs de concorrência do mundo real, selecionados aleatoriamente, provenientes de 4 aplicativos de código aberto representativos de servidor e cliente (MySQL, Apache, Mozilla e OpenOffice).

Nosso estudo revela várias descobertas interessantes e oferece orientações úteis para detecção de bugs de concorrência, testes e design de linguagens de programação concorrentes.

Algumas de nossas descobertas são as seguintes: (1) Cerca de um terço dos bugs de concorrência não relacionados a deadlock examinados são causados por violações das intenções de ordem dos programadores, que podem não ser facilmente expressas por meio de primitivas de sincronização como locks e memórias transacionais; (2) Aproximadamente 34% dos bugs de concorrência não relacionados a deadlock examinados envolvem várias variáveis, que não são bem abordadas pelas ferramentas existentes de detecção de bugs; (3) Cerca de 92% dos bugs de concorrência examinados podem ser acionados de forma confiável ao impor certas ordens entre não mais que 4 acessos à memória. Isso indica que testar programas concorrentes pode se concentrar em explorar ordens possíveis entre pequenos grupos de acessos à memória, em vez de entre todos os acessos à memória; (4) Cerca de 73% dos bugs de concorrência não relacionados a deadlock examinados não foram corrigidos simplesmente adicionando ou alterando locks, e muitas das correções não foram corretas na primeira tentativa, indicando a dificuldade de raciocinar sobre execução concorrente pelos programadores.

## 1 Introdução
### 1.1 Motivação
Programas concorrentes estão se tornando predominantes devido à realidade do hardware multi-core. Hoje em dia, não apenas servidores de alta qualidade, mas também máquinas desktop precisam de programas concorrentes para aproveitar ao máximo seu hardware multi-core. Como resultado, a dificuldade da programação concorrente está afetando toda a comunidade de desenvolvimento de software, em vez de apenas alguns privilegiados. Escrever programas concorrentes de boa qualidade tornou-se crucialmente importante.

Infelizmente, escrever programas concorrentes corretos é difícil. A maioria dos programadores pensa de forma sequencial e, portanto, comete erros facilmente ao escrever programas concorrentes. Ainda pior, o notório não-determinismo de programas concorrentes torna os bugs de concorrência difíceis de repetir durante o diagnóstico interativo.

Abordar os desafios acima exigirá esforços de múltiplas direções relacionadas, incluindo aquelas listadas a seguir, todas as quais progrediram nos últimos anos, mas ainda têm muitas questões abertas e não resolvidas:

**(1) Detecção de bugs de concorrência** A maioria das pesquisas anteriores sobre detecção de bugs de concorrência concentrou-se na detecção de bugs de corrida de dados e bugs de deadlock. A corrida de dados ocorre quando dois acessos conflitantes a uma variável compartilhada são executados sem a devida sincronização, por exemplo, sem proteção por um bloqueio comum. O deadlock ocorre quando duas ou mais operações esperam circularmente uma pela outra para liberar o recurso adquirido (por exemplo, locks). Recentemente, várias abordagens também foram propostas para detectar bugs de violação de atomicidade, causados pela execução concorrente que viola inesperadamente a atomicidade de uma determinada região de código. Embora trabalhos anteriores tenham proposto métodos eficazes para detectar certos tipos de bugs de concorrência, ainda estamos longe de fornecer uma solução completa. Em particular, várias questões em aberto sobre detecção de bugs de concorrência ainda permanecem: (i) As ferramentas de detecção de bugs existentes conseguem detectar todos os bugs de concorrência do mundo real? Especificamente, quais tipos de bugs de concorrência existem no mundo real? Há algum tipo que ainda não foi abordado por trabalhos existentes? Além disso, as suposições das ferramentas existentes sobre bugs de concorrência são válidas? Por exemplo, a maioria das técnicas anteriores de detecção de corrida e muitas técnicas de detecção de bugs de atomicidade concentram-se na sincronização entre acessos a uma única variável. Quantos bugs de concorrência são perdidos por essa suposição de variável única? (ii) Quão úteis são as ferramentas existentes para diagnosticar e corrigir bugs de concorrência do mundo real detectados por elas? Por exemplo, muitas ferramentas de detecção de bugs de concorrência alertam os programadores de que alguns acessos conflitantes não são protegidos pelo mesmo bloqueio. Essas informações podem ajudar os programadores a adicionar ou alterar operações de bloqueio. No entanto, com que frequência bugs do mundo real são corrigidos adicionando ou alterando operações de bloqueio? Mais genericamente, como os programadores corrigem bugs de concorrência do mundo real e de que informações eles precisam?


**(2) Testes de programas concorrentes e verificação de modelos**. Testar é uma prática comum no desenvolvimento de software, sendo uma etapa crítica para expor bugs de software antes do lançamento. As técnicas de teste existentes concentram-se principalmente nos aspectos sequenciais dos programas, como declarações, ramos, etc., e não conseguem abordar efetivamente os aspectos de concorrência de programas concorrentes, como interleavings de várias threads (ou processos) [28]. O principal desafio dos testes de concorrência é o espaço de interleavings exponencial de programas concorrentes. Expor bugs de concorrência requer não apenas uma entrada que exponha bugs, mas também um interleaving de execução que acione o bug. Portanto, para alcançar uma cobertura de teste completa de programas concorrentes, os testes precisam abranger todos os interleavings possíveis para cada caso de teste de entrada [39], o que é inviável na prática. Para enfrentar esse desafio, uma pergunta em aberto nos testes de concorrência é: podemos testar seletivamente um pequeno número de interleavings representativos e ainda expor a maioria dos bugs de concorrência? Motivado por esse problema, trabalhos anteriores, como o projeto ConTest [4, 9], propuseram alguns métodos para perturbar a execução do programa e forçar certos interleavings injetando atrasos artificiais após cada ponto de sincronização. Embora uma tentativa inspiradora, não está claro, quantitativa e qualitativamente, que parte dos bugs de concorrência pode ser exposta por tais heurísticas. Em última análise, projetar casos de teste práticos e eficazes para programas concorrentes exige uma boa compreensão das condições de manifestação dos bugs de concorrência do mundo real. Ou seja, precisamos saber quais condições são necessárias, além das entradas do programa, para acionar confiavelmente um bug de concorrência. Especificamente, quantas threads, quantas variáveis e quantos acessos geralmente estão envolvidos na manifestação de um bug de concorrência do mundo real?

Essas questões similares também são encontradas na verificação de software e na verificação de modelos [13, 28, 34] para programas concorrentes. Uma compreensão melhor da manifestação dos bugs de concorrência do mundo real pode ajudar a verificação de modelos a priorizar os estados do programa e aliviar seu problema de explosão de estados.

**(3) Design de linguagens de programação concorrentes**. Boas linguagens de programação concorrentes podem ajudar os programadores a expressar corretamente suas intenções e, portanto, evitar certos tipos de bugs de concorrência. Nessa direção, a memória transacional (TM) [1,2,15,16,25,26,27,36] é uma das tendências populares. A TM fornece aos programadores uma maneira mais fácil de especificar quais regiões de código devem ser atômicas. Além disso, ela protege automaticamente a atomicidade da região especificada contra outras regiões especificadas por meio de suporte subjacente de hardware e software. Embora a TM mostre grande potencial, há muitas questões em aberto, incluindo (i) Que parte dos bugs pode ser evitada usando a TM? (ii) Quais são as preocupações do mundo real que o design da TM precisa observar? (iii) Além da TM, que outros suportes de linguagem de programação serão úteis para os programadores escreverem programas concorrentes corretos?

beneficiado significativamente por uma compreensão aprimorada das características de bugs de concorrência do mundo real. Basicamente, podemos aprender com os erros comuns que os programadores cometem ao escrever programas concorrentes. Por exemplo, se muitos bugs de concorrência do mundo real envolvem várias variáveis compartilhadas, precisamos estender as técnicas de detecção de bugs de concorrência para lidar com bugs de concorrência com várias variáveis; se a manifestação da maioria dos bugs de concorrência do mundo real é garantida por uma ordem parcial entre apenas duas threads, os testes de programas concorrentes só precisam abranger interleavings em pares para cada par de threads do programa; se houver preocupações em evitar bugs de concorrência do mundo real com primitivas de sincronização existentes, podemos estender o modelo de memória transacional ou projetar novos suportes de linguagem para facilitar ainda mais a escrita de programas concorrentes; se um certo tipo de informação é frequentemente usada por programadores na correção de bugs de concorrência do mundo real, as ferramentas de detecção de bugs podem ser estendidas para fornecer essa informação e, assim, se tornarem mais úteis na prática.

No passado, muitos estudos empíricos sobre características gerais de bugs de programas (não específicos para bugs de concorrência) foram realizados. Suas descobertas forneceram diretrizes úteis e motivações para detecção de bugs, testes e design de linguagens de programação. Por exemplo, o estudo de tipos de bugs em sistemas de software da IBM [38] na década de 1990 demonstrou a importância de bugs de memória e motivou muitas ferramentas de detecção de bugs de memória comerciais e de código aberto, como Purify [18], Valgrind [30], CCured [29], etc. Um estudo recente de bugs em sistemas operacionais [8] revelou que a cópia e cola era uma causa importante de bugs semânticos e inspirou uma ferramenta chamada CP-Miner, que se concentrou em detectar código copiado e bugs semânticos relacionados à cópia e cola [19].

Infelizmente, poucos estudos foram conduzidos sobre as características reais de bugs de concorrência do mundo real. Pesquisadores, percebendo a importância de tal estudo, realizaram um trabalho preliminar sobre as características de bugs de concorrência [11]. No entanto, eles basearam suas observações em programas intencionalmente tornados com bugs por estudantes para o estudo das características.

A falta de um bom estudo de características reais de bugs de concorrência do mundo real se deve principalmente a duas razões:

(1) É difícil coletar bugs de concorrência do mundo real, especialmente porque geralmente são subnotificados. Como observado em trabalhos anteriores [6], o não determinismo dificultou que os usuários relatassem bugs de concorrência e tornou os relatos de bugs de concorrência difíceis de entender e resolver por programadores. Portanto, é demorado coletar um conjunto bom de bugs de concorrência do mundo real.

(2) Bugs de concorrência não são fáceis de entender. Seus padrões e manifestações geralmente envolvem interações complicadas entre vários componentes do programa e, portanto, são difíceis de entender.

### 1.2 Contribuições
Este trabalho fornece o primeiro (até onde sabemos) estudo abrangente das características de bugs de concorrência do mundo real. Especificamente, examinamos os padrões de bugs, manifestações, estratégias de correção e outras características de bugs de concorrência do mundo real. Nosso estudo é baseado em 105 bugs de concorrência do mundo real, selecionados aleatoriamente, incluindo 74 bugs não relacionados a deadlock e 31 bugs relacionados a deadlock, coletados de quatro aplicativos de código aberto grandes e maduros: MySQL, Apache, Mozilla e OpenOffice, representando tanto aplicações de servidor quanto de cliente. Para cada bug, examinamos cuidadosamente seu relatório de bug, código-fonte correspondente, patches relacionados e discussões entre programadores, fornecendo, assim, uma compreensão relativamente completa dos padrões de bugs, condições de manifestação, estratégias de correção e processos de diagnóstico.

Nosso estudo revela diversas descobertas interessantes, oferecendo orientações úteis para detecção de bugs de concorrência, testes de programas concorrentes e design de linguagens de programação concorrentes. Resumimos nossas principais descobertas e suas implicações na Tabela 1.

Embora acreditemos que as aplicações e bugs examinados representem bem um grande conjunto de aplicações concorrentes, não pretendemos tirar conclusões gerais sobre todas as aplicações concorrentes. Em particular, devemos observar que todas as características e descobertas obtidas neste estudo estão associadas aos quatro aplicativos examinados e às linguagens de programação que essas aplicações utilizam. Portanto, os resultados devem ser considerados levando em conta as aplicações específicas e nossa metodologia de avaliação (consulte a Seção 2.3 para nossa discussão sobre ameaças à validade).
